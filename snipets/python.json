{
  "forProgrammingContest": {
    "prefix": "pro",
    "body": [
      "#!usr/bin/env python3",
      "from collections import defaultdict",
      "from collections import deque",
      "from heapq import heappush, heappop",
      "from functools import reduce",
      "import sys",
      "import math",
      "import bisect",
      "import random",
      "def I(): return int(sys.stdin.readline())",
      "def F(): return float(sys.stdin.readline())",
      "def S(): return input()",
      "def LI(): return list(map(int, sys.stdin.readline().split()))",
      "def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]",
      "def LF(): return list(map(float, sys.stdin.readline().split()))",
      "def LS():return sys.stdin.readline().split()",
      "def SR(n): return [list(sys.stdin.readline())[:-1] for i in range(n)]",
      "def IR(n): return [int(sys.stdin.readline()) for i in range(n)]",
      "def LIR(n): return [list(map(int, sys.stdin.readline().split())) for i in range(n)]",
      "def LSR(n): return [list(map(list, sys.stdin.readline().split())) for i in range(n)]",
      "_gcd = lambda x, y: _gcd(y, x%y) if (x%y) else y",
      "_lcm = lambda x, y: x*y // _gcd(x, y)",
      "def gcd(*numbers):",
      "    return reduce(_gcd, numbers)",
      "def lcm(*numbers):",
      "    return reduce(_lcm, numbers)",
      "sys.setrecursionlimit(1000000)",
      "INF = float('inf')",
      "mod = 1000000007",
      "dire4 = [(1,0), (0,1), (-1,0), (0,-1)]",
      "dire8 = [(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)]"
    ]
  },
  "bfs": {
    "prefix": "bfs",
    "body": [
      "def bfs(c,sy=0, sx=0, gy=0, gx=0, blocks=['#'], dire=[(1,0), (0,1), (-1,0), (0,-1)], return_maximum_distance=False):",
      "   H = len(c)",
      "   W = len(c[0])",
      "   distance_limit = H*W+1",
      "   dist = [[distance_limit]*W for i in range(H)]",
      "",
      "   q = deque()",
      "",
      "   q_append = q.append",
      "   q_popleft = q.popleft",
      "",
      "   if (type(sy)==list) or (type(sx)==list):",
      "       for syi, sxi in zip(sy, sx):",
      "           dist[syi][sxi] = 0",
      "           q.append((syi, sxi))",
      "   else:",
      "       dist[sy][sx] = 0",
      "       q_append((sy, sx))",
      "",
      "   while q:",
      "       y, x = q_popleft()",
      "       d = dist[y][x]",
      "       for dy, dx in dire:",
      "           if (y+dy<H) and (y+dy>=0) and (x+dx<W) and (x+dx>=0):",
      "               if (c[y+dy][x+dx] in blocks):",
      "                   continue",
      "               else:",
      "                   if (y+dy==gy) and (x+dx==gx) and (not return_maximum_distance):",
      "                       return (d+1)",
      "                   elif (dist[y+dy][x+dx] > d+1):",
      "                       dist[y+dy][x+dx] = d+1",
      "                       q_append((y+dy, x+dx))",
      "   if (return_maximum_distance):",
      "       return d",
      "   return -1"
    ]
  }
}
