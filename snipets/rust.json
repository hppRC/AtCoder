{
  "read line": {
    "prefix": "readln",
    "body": [
      "fn get_line() -> String {",
      "    let mut s = String::new();",
      "    std::io::stdin().read_line(&mut s).ok();",
      "    s.trim().to_string()",
      "}",
      "fn readln<T>() -> T",
      "    where",
      "        T: std::str::FromStr,",
      "        <T as std::str::FromStr>::Err: std::fmt::Debug {",
      "    get_line().parse().unwrap()",
      "}"
    ]
  },

  "UnionFind": {
    "prefix": "union",
    "body": [
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "struct UnionFind {",
      "    par: Vec<usize>,",
      "    rank: Vec<usize>,",
      "    group: Vec<usize>,",
      "}",
      "#[allow(dead_code)]",
      "impl UnionFind {",
      "    fn new(n: usize) -> Self {",
      "        UnionFind {",
      "            par: (0..n).collect(),",
      "            rank: vec![0; n],",
      "            group: vec![1; n],",
      "        }",
      "    }",
      "    fn find(&mut self, x: usize) -> usize {",
      "        if self.par[x] == x {",
      "            x",
      "        } else {",
      "            let px = self.par[x];",
      "            let root = self.find(px);",
      "            self.par[x] = root;",
      "            root",
      "        }",
      "    }",
      "    fn unite(&mut self, x: usize, y: usize) {",
      "        let x = self.find(x);",
      "        let y = self.find(y);",
      "        if x == y {",
      "            return",
      "        }",
      "        if self.rank[x] < self.rank[y] {",
      "            self.group[y] += self.group[x];",
      "            self.par[x] = y;",
      "        } else {",
      "            self.group[x] += self.group[y];",
      "            self.par[y] = x;",
      "        }",
      "        if self.rank[x] == self.rank[y] {",
      "            self.rank[y] += 1;",
      "        }",
      "    }",
      "    fn group_size(&mut self, x: usize) -> usize {",
      "        let p = self.find(x);",
      "        self.group[p]",
      "    }",
      "}"
    ]
  },

  "directions": {
    "prefix": "dire",
    "body": [
      "let dire: Vec<(isize, isize)> = vec![(1, 0), (0, 1), (-1, 0), (0, -1)];",
      "let dire8: Vec<(isize, isize)> = vec![(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)];"
    ]
  },

  "gcd": {
    "prefix": "gcd",
    "body": [
      "fn gcd(a: usize, b: usize) -> usize {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}"
    ]
  },
  "lcm": {
    "prefix": "lcm",
    "body": [
      "fn lcm(a: usize, b:usize) -> usize {",
      "    a * b / gcd(a, b)",
      "}"
    ]
  },
  "mod_pow": {
    "prefix": "modp",
    "body": [
      "fn mod_pow(x: usize, n: usize, m: usize) -> usize {",
      "    let mut res = 1;",
      "    let mut x = x;",
      "    let mut n = n;",
      "    while n > 0 {",
      "        if n & 1 == 1 {",
      "            res = (res * x) % m;",
      "        }",
      "        x = (x * x) % m;",
      "        n = n >> 1;",
      "    }",
      "    res",
      "}"
    ]
  },
  "mod_inverse": {
    "prefix": "modi",
    "body": [
      "fn mod_inv(a: usize, m: usize) -> usize {",
      "    let (_, x, _) = extgcd(a as i64, m as i64);",
      "    (m as i64 + x) as usize % m",
      "}"
    ]
  },
  "extended gcd": {
    "prefix": "extg",
    "body": [
      "fn extgcd(a: i64, b: i64) -> (i64, i64, i64) {",
      "    if b == 0 {",
      "        (a, 1, 0)",
      "    } else {",
      "        let (gcd, x, y) = extgcd(b, a % b);",
      "        (gcd, y, x - (a / b) * y)",
      "    }",
      "}"
    ]
  },

  "FactInverse": {
    "prefix": "facti",
    "body": [
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "struct FactInv {",
      "    fact: Vec<usize>,",
      "    inv: Vec<usize>,",
      "    factinv: Vec<usize>,",
      "    m: usize,",
      "}",
      "#[allow(dead_code)]",
      "impl FactInv {",
      "    fn new(n: usize, m: usize) -> Self {",
      "        let mut fact: Vec<usize> = vec![0; n + 1];",
      "        fact[0] = 1;",
      "        for i in 1..n+1 {",
      "            fact[i] = i * &fact[i - 1] % m;",
      "        }",
      "        let mut inv = vec![0; n + 1];",
      "        inv[0] = 0;",
      "        inv[1] = 1;",
      "        for i in 2..n+1 {",
      "            inv[i] = inv[m % i] * (m - m / i) % m;",
      "        }",
      "        let mut factinv = vec![0; n + 1];",
      "        factinv[0] = 1;",
      "        for i in 1..n+1 {",
      "            factinv[i] = factinv[i - 1] * inv[i] % m;",
      "        }",
      "        FactInv {",
      "            fact: fact,",
      "            inv: inv,",
      "            factinv: factinv,",
      "            m: m,",
      "        }",
      "    }",
      "    fn comb(&self, n: usize, r: usize) -> usize {",
      "        if n < r {",
      "            0",
      "        } else {",
      "            (self.fact[n] * self.factinv[r] % self.m) * self.factinv[n-r] % self.m",
      "        }",
      "    }",
      "}"
    ]
  },
  "alphabets": {
    "prefix": "alpha",
    "body": [
      "let alphabets = vec!['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];"
    ]
  },
  "digit_sum": {
    "prefix": "digits",
    "body": [
      "fn digit_sum(n: i64, b: i64) -> i64 {",
      "    if n < b {",
      "        n",
      "    } else {",
      "        digit_sum((n as f64/b as f64).floor() as i64, b) + (n % b)",
      "    }",
      "}"
    ]
  },
  "Binary Search": {
    "prefix": "bin",
    "body": [
      "pub trait BinarySearch<T> {",
      "    fn lower_bound(&self, x: &T) -> usize;",
      "    fn upper_bound(&self, x: &T) -> usize;",
      "}",
      "impl<T: Ord> BinarySearch<T> for [T] {",
      "    fn lower_bound(&self, x: &T) -> usize {",
      "        let mut low = 0;",
      "        let mut high = self.len();",
      "        while low != high {",
      "            let mid = (low + high) / 2;",
      "            match self[mid].cmp(x) {",
      "                Ordering::Less => {",
      "                    low = mid + 1;",
      "                }",
      "                Ordering::Equal | Ordering::Greater => {",
      "                    high = mid;",
      "                }",
      "            }",
      "        }",
      "        low",
      "    }",
      "    fn upper_bound(&self, x: &T) -> usize {",
      "        let mut low = 0;",
      "        let mut high = self.len();",

      "        while low != high {",
      "            let mid = (low + high) / 2;",
      "            match self[mid].cmp(x) {",
      "                Ordering::Less | Ordering::Equal => {",
      "                    low = mid + 1;",
      "                }",
      "                Ordering::Greater => {",
      "                    high = mid;",
      "                }",
      "            }",
      "        }",
      "        low",
      "    }",
      "}"
    ]
  },
  "Total Order": {
    "prefix": "total",
    "body": [
      "#[derive(PartialEq, PartialOrd, Clone, Debug)]",
      "pub struct Total<T>(pub T);",

      "impl<T: PartialEq> Eq for Total<T> {}",

      "impl<T: PartialOrd> Ord for Total<T> {",
      "    fn cmp(&self, other: &Total<T>) -> Ordering {",
      "        self.0.partial_cmp(&other.0).unwrap()",
      "    }",
      "}"
    ]
  },
  "Reverse": {
    "prefix": "reverse",
    "body": [
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "pub struct Rev<T>(pub T);",
      "impl<T: PartialOrd> PartialOrd for Rev<T> {",
      "    fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {",
      "        other.0.partial_cmp(&self.0)",
      "    }",
      "}",
      "impl<T: Ord> Ord for Rev<T> {",
      "    fn cmp(&self, other: &Rev<T>) -> Ordering {",
      "        other.0.cmp(&self.0)",
      "    }",
      "}"
    ]
  },
  "lexical permutation": {
    "prefix": "permu",
    "body": [
      "//thanks for https://github.com/bluss/permutohedron/blob/master/src/lexical.rs",
      "pub trait LexicalPermutation {",
      "    fn next_permutation(&mut self) -> bool;",
      "    fn prev_permutation(&mut self) -> bool;",
      "}",
      "impl<T> LexicalPermutation for [T] where T: Ord {",
      "    fn next_permutation(&mut self) -> bool {",
      "        if self.len() < 2 { return false; }",
      "        let mut i = self.len() - 1;",
      "        while i > 0 && self[i-1] >= self[i] {",
      "            i -= 1;",
      "        }",
      "        if i == 0 {",
      "            return false;",
      "        }",
      "        let mut j = self.len() - 1;",
      "        while j >= i && self[j] <= self[i-1]  {",
      "            j -= 1;",
      "        }",
      "        self.swap(j, i-1);",
      "        self[i..].reverse();",
      "        true",
      "    }",
      "    fn prev_permutation(&mut self) -> bool {",
      "        if self.len() < 2 { return false; }",
      "        let mut i = self.len() - 1;",
      "        while i > 0 && self[i-1] <= self[i] {",
      "            i -= 1;",
      "        }",
      "        if i == 0 {",
      "            return false;",
      "        }",
      "        self[i..].reverse();",
      "        let mut j = self.len() - 1;",
      "        while j >= i && self[j-1] < self[i-1]  {",
      "            j -= 1;",
      "        }",
      "        self.swap(i-1, j);",
      "        true",
      "    }",
      "}"
    ]
  },
  "Warshall Floyd": {
    "prefix": "warshallfloyd",
    "body": [
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "struct WarshallFloyd {",
      "    dist: Vec<Vec<isize>>,",
      "    next: Vec<Vec<usize>>,",
      "    n: usize,",
      "}",
      "#[allow(dead_code)]",
      "impl WarshallFloyd {",
      "    fn new(n: usize, edges: &Vec<(usize, usize, isize)>) -> Self {",
      "        let inf: isize = 1000000007;",
      "        let mut dist: Vec<Vec<isize>> = vec![vec![inf as isize; n]; n];",
      "        let mut next: Vec<Vec<usize>> = vec![vec![0; n]; n];",
      "        for &(a, b, c) in edges.into_iter() {",
      "            dist[a][b] = c;",
      "        }",
      "        for i in 0..n {",
      "            dist[i][i] = 0;",
      "        }",
      "        for i in 0..n {",
      "            for j in 0..n {",
      "                next[i][j] = j;",
      "            }",
      "        }",
      "        for k in 0..n {",
      "            for i in 0..n {",
      "                for j in 0..n {",
      "                    if dist[i][j] > dist[i][k] + dist[k][j] {",
      "                        dist[i][j] = dist[i][k] + dist[k][j];",
      "                        next[i][j] = next[i][k];",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        WarshallFloyd {",
      "            dist: dist,",
      "            next: next,",
      "            n: n",
      "        }",
      "    }",
      "    fn get_path(&mut self, i: usize, j: usize) -> Vec<usize> {",
      "        let mut path = vec![];",
      "        let mut to = self.next[i][j];",
      "        path.push(i);",
      "        while to != j {",
      "            path.push(to);",
      "            to = self.next[to][j];",
      "        }",
      "        path.push(to);",
      "        path",
      "    }",
      "    fn has_negative_loop(&mut self) -> bool {",
      "        for i in 0..self.n {",
      "            if self.dist[i][i] < 0 {",
      "                return true",
      "            }",
      "        }",
      "        false",
      "    }",
      "}"
    ]
  },
  "Eratosthenes": {
    "prefix": "eratosthenes",
    "body": [
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "struct Eratosthenes {",
      "    end: usize,",
      "    primes: Vec<usize>,",
      "    flags: Vec<usize>,",
      "}",
      "#[allow(dead_code)]",
      "impl Eratosthenes {",
      "    fn new(n: usize) -> Self {",
      "        let bits = 32;",
      "        let flags_num = n / bits + 1;",
      "        let defaults: Vec<usize> = vec![0x5D75D75D, 0xD75D75D7, 0x75D75D75];",
      "        let (mut i, mut f, mut j);",
      "        let max = ((n as f32).sqrt() as usize) + 1;",
      "        let mut flags: Vec<usize> = (0..flags_num).map(|i| defaults[i % 3]).collect();",
      "        flags[flags_num - 1] &= (1 << (n % bits + 1)) - 1 ;",
      "        i = 5;",
      "        f = 4;",
      "        while i <= max {",
      "            let t = (flags[i / bits] >> (i % bits)) & 1 == 1;",
      "            if !t {",
      "                j = i * (i | 1);",
      "                while j <= n {",
      "                    flags[j / bits] |= 1 << (j % bits);",
      "                    j += i * 2;",
      "                }",
      "            }",
      "            f = 6 - f;",
      "            i += f;",
      "        }",
      "        flags[0] &= !0b1100;",
      "        flags[0] |= 0b11;",
      "        let mut primes = vec![];",
      "        for p in 2..n+1 {",
      "            if (flags[p / bits] >> (p % bits)) & 1 == 0 {",
      "                primes.push(p);",
      "            }",
      "        }",
      "        Eratosthenes {",
      "            end: n,",
      "            primes: primes,",
      "            flags: flags,",
      "        }",
      "    }",
      "    fn is_prime(&self, m: usize) -> bool {",
      "        self.flags[m / 32] >> (m % 32) & 1 == 0",
      "    }",
      "    fn factorization(&self, n: usize) -> HashMap<usize, usize> {",
      "        let mut n = n;",
      "        let mut factors: HashMap<usize, usize> = HashMap::new();",
      "        for &p in &self.primes {",
      "            while n % p == 0 {",
      "                n /= p;",
      "                *factors.entry(p).or_insert(0) += 1;",
      "            }",
      "            if p > n {",
      "                break;",
      "            }",
      "        }",
      "        factors",
      "    }",
      "}"
    ]
  },
  "Dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "struct Dijkstra {",
      "    dist: Vec<isize>,",
      "    neighbors: Vec<Vec<(usize, isize)>>,",
      "    n: usize,",
      "}",
      "#[allow(dead_code)]",
      "impl Dijkstra {",
      "    fn new(n: usize, edges: &Vec<(usize, usize, isize)>, s: usize) -> Self {",
      "        let inf: isize = 1000000007;",
      "        let mut dist: Vec<isize> = vec![inf; n];",
      "        let mut neighbors: Vec<Vec<(usize, isize)>> = vec![vec![]; n];",
      "        let mut heap: BinaryHeap<Rev<(usize, isize)>> = BinaryHeap::new();",
      "        for &(a, b, c) in edges.into_iter() {",
      "            neighbors[a].push((b, c));",
      "        }",
      "        dist[s] = 0;",
      "        heap.push(Rev((s, 0)));",
      "        while !heap.is_empty() {",
      "            let Rev((v, d)) = heap.pop().unwrap();",
      "            if dist[v] < d {",
      "                continue;",
      "            }",
      "            for &(u, cost) in &neighbors[v] {",
      "                if dist[u] > dist[v] + cost {",
      "                    dist[u] = dist[v] + cost;",
      "                    heap.push(Rev((u, cost)));",
      "                }",
      "            }",
      "        }",
      "        Dijkstra {",
      "            dist: dist,",
      "            neighbors: neighbors,",
      "            n: n,",
      "        }",
      "    }",
      "}"
    ]
  },
  "debug": {
    "prefix": "debugmacro",
    "body": [
      "macro_rules! debug {",
      "    (\\$(\\$a:expr),*) => {",
      "        println!(concat!(\\$(stringify!(\\$a), \" = {:?}, \"),*), \\$(\\$a),*);",
      "    }",
      "}"
    ]
  },
  "Neighbor list": {
    "prefix": "neighbor",
    "body": [
      "let mut g: Vec<Vec<usize>> = vec![vec![]; N];",
      "for &(a, b) in &ab {",
      "    g[a].push(b);",
      "    g[b].push(a);",
      "}"
    ]
  },
  "print vector": {
    "prefix": "printvec",
    "body": [
      "macro_rules! printvec {",
      "    ( \\$item:expr ) => {",
      "        for &i in &\\$item {",
      "            print!(\"{} \", i);",
      "        }",
      "        println!(\"\");",
      "    }",
      "}"
    ]
  },
  "LowestCommonAncestor": {
    "prefix": "LowestCommonAncestor",
    "body": [
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "struct LowestCommonAncestor {",
      "    g: Vec<Vec<usize>>,",
      "    parent: Vec<Vec<Option<usize>>>,",
      "    depth: Vec<usize>,",
      "}",
      "#[allow(dead_code)]",
      "impl LowestCommonAncestor {",
      "    fn new(n: usize, edges: &[(usize, usize)]) -> Self",
      "    {",
      "        let mut g = vec![vec![]; n];",
      "        for &(a, b) in edges.into_iter() {",
      "            g[a].push(b);",
      "            g[b].push(a);",
      "        }",
      "        let log_n = (1..).find(|i| (1usize << i) > n).unwrap();;",
      "        let mut parent = vec![vec![None; n]; log_n];",
      "        let mut depth = vec![0; n];",
      "        LowestCommonAncestor::build(n, log_n, &g, &mut parent, &mut depth);",
      "        LowestCommonAncestor {",
      "            g: g,",
      "            parent: parent,",
      "            depth: depth,",
      "        }",
      "    }",
      "    fn build(",
      "        n: usize,",
      "        log_n: usize,",
      "        g: &[Vec<usize>],",
      "        parent: &mut [Vec<Option<usize>>],",
      "        depth: &mut [usize],",
      "    ) -> () {",
      "        LowestCommonAncestor::dfs(0, None, 0, g, parent, depth);",
      "        for k in 0..log_n-1 {",
      "            for v in 0..n {",
      "                if parent[k][v] == None {",
      "                    parent[k+1][v] = None;",
      "                } else {",
      "                    let super_parent = parent[k][v].unwrap();",
      "                    parent[k+1][v] = parent[k][super_parent];",
      "                }",
      "            }",
      "        }",
      "    }",
      "    fn dfs(",
      "        v: usize,",
      "        p: Option<usize>,",
      "        d: usize,",
      "        g: &[Vec<usize>],",
      "        parent: &mut [Vec<Option<usize>>],",
      "        depth: &mut [usize],",
      "    ) -> () {",
      "        parent[0][v] = p;",
      "        depth[v] = d;",
      "        for &u in &g[v] {",
      "            if Some(u) != p {",
      "                LowestCommonAncestor::dfs(u, Some(v), d+1, g, parent, depth);",
      "            }",
      "        }",
      "    }",
      "    fn lca(&self, mut a: usize, mut b: usize) -> usize {",
      "        if self.depth[a] > self.depth[b] {",
      "            std::mem::swap(&mut a, &mut b);",
      "        }",
      "        while self.depth[a] != self.depth[b] {",
      "            b = self.parent[(self.depth[b] - self.depth[a]).trailing_zeros() as usize][b].unwrap();",
      "        }",
      "        if a == b {",
      "            return a;",
      "        }",
      "        for k in (0..self.parent.len()).rev() {",
      "            if self.parent[k][a] != self.parent[k][b] {",
      "                a = self.parent[k][a].unwrap();",
      "                b = self.parent[k][b].unwrap();",
      "            }",
      "        }",
      "        self.parent[0][a].unwrap()",
      "    }",
      "    fn dist(&self, a: usize, b: usize) -> usize {",
      "        self.depth[a] + self.depth[b] - 2 * self.depth[self.lca(a, b)]",
      "    }",
      "}"
    ]
  },

  "ForestLowestCommonAncestor": {
    "prefix": "ForestLowestCommonAncestor",
    "body": [
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "struct ForestLowestCommonAncestor {",
      "    g: Vec<Vec<usize>>,",
      "    parent: Vec<Vec<Option<usize>>>,",
      "    depth: Vec<usize>,",
      "}",
      "#[allow(dead_code)]",
      "impl ForestLowestCommonAncestor {",
      "    fn new(n: usize, edges: &[(usize, usize)]) -> Self",
      "    {",
      "        let mut g = vec![vec![]; n];",
      "        for &(a, b) in edges.into_iter() {",
      "            g[a].push(b);",
      "            g[b].push(a);",
      "        }",
      "        let log_n = (1..).find(|i| (1usize << i) > n).unwrap();;",
      "        let mut parent = vec![vec![None; n]; log_n];",
      "        let mut depth = vec![0; n];",
      "        let mut visit = vec![false; n];",
      "        ForestLowestCommonAncestor::build(",
      "            n,",
      "            log_n,",
      "            &g,",
      "            &mut parent,",
      "            &mut depth,",
      "            &mut visit,",
      "        );",
      "        ForestLowestCommonAncestor {",
      "            g: g,",
      "            parent: parent,",
      "            depth: depth,",
      "        }",
      "    }",
      "    fn build(",
      "        n: usize,",
      "        log_n: usize,",
      "        g: &[Vec<usize>],",
      "        parent: &mut [Vec<Option<usize>>],",
      "        depth: &mut [usize],",
      "        visit: &mut [bool],",
      "    ) -> () {",
      "        for v in 0..n {",
      "            if !visit[v] {",
      "                ForestLowestCommonAncestor::dfs(v, None, 0, g, parent, depth, visit);",
      "            }",
      "        }",
      "        for k in 0..log_n-1 {",
      "            for v in 0..n {",
      "                if parent[k][v] == None {",
      "                    parent[k+1][v] = None;",
      "                } else {",
      "                    let super_parent = parent[k][v].unwrap();",
      "                    parent[k+1][v] = parent[k][super_parent];",
      "                }",
      "            }",
      "        }",
      "    }",
      "    fn dfs(",
      "        v: usize,",
      "        p: Option<usize>,",
      "        d: usize,",
      "        g: &[Vec<usize>],",
      "        parent: &mut [Vec<Option<usize>>],",
      "        depth: &mut [usize],",
      "        visit: &mut [bool],",
      "    ) -> () {",
      "        parent[0][v] = p;",
      "        depth[v] = d;",
      "        visit[v] = true;",
      "        for &u in &g[v] {",
      "            if !visit[u] {",
      "                ForestLowestCommonAncestor::dfs(u, Some(v), d+1, g, parent, depth, visit);",
      "            }",
      "        }",
      "    }",
      "    fn lca(&self, mut a: usize, mut b: usize) -> Option<usize> {",
      "        if self.depth[a] > self.depth[b] {",
      "            std::mem::swap(&mut a, &mut b);",
      "        }",
      "        while self.depth[a] != self.depth[b] {",
      "            b = self.parent[(self.depth[b] - self.depth[a]).trailing_zeros() as usize][b].unwrap();",
      "        }",
      "        if a == b {",
      "            return Some(a);",
      "        }",
      "        for k in (0..self.parent.len()).rev() {",
      "            if self.parent[k][a] != self.parent[k][b] {",
      "                a = self.parent[k][a].unwrap();",
      "                b = self.parent[k][b].unwrap();",
      "            }",
      "        }",
      "        if self.parent[0][a] == None && self.parent[0][b] == None {",
      "            None",
      "        } else {",
      "            self.parent[0][a]",
      "        }",
      "    }",
      "    fn dist(&self, a: usize, b: usize) -> Option<usize> {",
      "        if let Some(lca) = self.lca(a, b) {",
      "            Some(self.depth[a] + self.depth[b] - 2 * self.depth[lca])",
      "        } else {",
      "            None",
      "        }",
      "    }",
      "}"
    ]
  },

  "WeightedForestLowestCommonAncestor": {
    "prefix": "WeightedForestLowestCommonAncestor",
    "body": [
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "struct WeightedForestLowestCommonAncestor {",
      "    g: Vec<Vec<(usize, usize)>>,",
      "    parent: Vec<Vec<Option<usize>>>,",
      "    weight: Vec<Vec<Option<usize>>>,",
      "    depth: Vec<usize>,",
      "}",
      "#[allow(dead_code)]",
      "impl WeightedForestLowestCommonAncestor {",
      "    fn new<T>(n: usize, edges: &[(usize, usize, usize)], comp: T) -> Self",
      "        where T: Fn(usize, usize) -> usize",
      "    {",
      "        let mut g = vec![vec![]; n];",
      "        for &(a, b, cost) in edges.into_iter() {",
      "            g[a].push((b, cost));",
      "            g[b].push((a, cost));",
      "        }",
      "        let log_n = (1..).find(|i| (1usize << i) > n).unwrap();;",
      "        let mut parent = vec![vec![None; n]; log_n];",
      "        let mut weight = vec![vec![None; n]; log_n];",
      "        let mut depth = vec![0; n];",
      "        let mut visit = vec![false; n];",
      "        WeightedForestLowestCommonAncestor::build(",
      "            n,",
      "            log_n,",
      "            &g,",
      "            &mut parent,",
      "            &mut weight,",
      "            &mut depth,",
      "            &mut visit,",
      "            &comp",
      "        );",
      "        WeightedForestLowestCommonAncestor {",
      "            g: g,",
      "            parent: parent,",
      "            weight: weight,",
      "            depth: depth,",
      "        }",
      "    }",
      "    fn build<T>(",
      "        n: usize,",
      "        log_n: usize,",
      "        g: &[Vec<(usize, usize)>],",
      "        parent: &mut [Vec<Option<usize>>],",
      "        weight: &mut [Vec<Option<usize>>],",
      "        depth: &mut [usize],",
      "        visit: &mut [bool],",
      "        comp: T",
      "    ) -> ()",
      "        where T: Fn(usize, usize) -> usize",
      "    {",
      "        for v in 0..n {",
      "            if !visit[v] {",
      "                WeightedForestLowestCommonAncestor::dfs(v, None, 0, g, parent, weight, depth, visit);",
      "            }",
      "        }",
      "        for k in 0..log_n-1 {",
      "            for v in 0..n {",
      "                if parent[k][v] == None {",
      "                    parent[k+1][v] = None;",
      "                } else {",
      "                    let super_parent = parent[k][v].unwrap();",
      "                    parent[k+1][v] = parent[k][super_parent];",
      "                    if parent[k+1][v] != None {",
      "                        let weight_p = weight[k][v].unwrap();",
      "                        let weight_sp = weight[k][super_parent].unwrap();",
      "                        weight[k+1][v] = Some(comp(weight_p, weight_sp));",
      "                    } else {",
      "                        weight[k+1][v] = None;",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    }",
      "    fn dfs(",
      "        v: usize,",
      "        p: Option<usize>,",
      "        d: usize,",
      "        g: &[Vec<(usize, usize)>],",
      "        parent: &mut [Vec<Option<usize>>],",
      "        weight: &mut [Vec<Option<usize>>],",
      "        depth: &mut [usize],",
      "        visit: &mut [bool],",
      "    ) -> () {",
      "        parent[0][v] = p;",
      "        depth[v] = d;",
      "        visit[v] = true;",
      "        for &(u, cost) in &g[v] {",
      "            if !visit[u] {",
      "                weight[0][u] = Some(cost);",
      "                WeightedForestLowestCommonAncestor::dfs(u, Some(v), d+1, g, parent, weight, depth, visit);",
      "            }",
      "        }",
      "    }",
      "    fn lca(&self, mut a: usize, mut b: usize) -> Option<usize> {",
      "        if self.depth[a] > self.depth[b] {",
      "            std::mem::swap(&mut a, &mut b);",
      "        }",
      "        while self.depth[a] != self.depth[b] {",
      "            b = self.parent[(self.depth[b] - self.depth[a]).trailing_zeros() as usize][b].unwrap();",
      "        }",
      "        if a == b {",
      "            return Some(a);",
      "        }",
      "        for k in (0..self.parent.len()).rev() {",
      "            if self.parent[k][a] != self.parent[k][b] {",
      "                a = self.parent[k][a].unwrap();",
      "                b = self.parent[k][b].unwrap();",
      "            }",
      "        }",
      "        if self.parent[0][a] == None && self.parent[0][b] == None {",
      "            None",
      "        } else {",
      "            self.parent[0][a]",
      "        }",
      "    }",
      "    fn dist(&self, a: usize, b: usize) -> Option<usize> {",
      "        self.query_interface(a, b, |x, y| { x + y }, 0)",
      "    }",
      "    fn max_path_weight(&self, a: usize, b: usize) -> Option<usize> {",
      "        self.query_interface(a, b, |x, y| { std::cmp::max(x, y) }, 0)",
      "    }",
      "    fn min_path_weight(&self, a: usize, b: usize) -> Option<usize> {",
      "        let inf = 1000000007;",
      "        self.query_interface(a, b, |x, y| { std::cmp::min(x, y) }, inf)",
      "    }",
      "    fn query_interface<T>(&self, mut a: usize, mut b: usize, f: T, init_ret: usize) -> Option<usize>",
      "        where T: Fn(usize, usize) -> usize",
      "    {",
      "        if a == b {",
      "            return None",
      "        }",
      "        let mut ret = init_ret;",
      "        if self.depth[a] > self.depth[b] {",
      "            std::mem::swap(&mut a, &mut b);",
      "        }",
      "        while self.depth[a] != self.depth[b] {",
      "            let step = (self.depth[b] - self.depth[a]).trailing_zeros() as usize;",
      "            ret = f(ret, self.weight[step][b].unwrap());",
      "            b = self.parent[step][b].unwrap();",
      "        }",
      "        if a == b {",
      "            return Some(ret);",
      "        }",
      "        for k in (0..self.parent.len()).rev() {",
      "            if self.parent[k][a] != self.parent[k][b] {",
      "                ret = f(ret, self.weight[k][a].unwrap());",
      "                ret = f(ret, self.weight[k][b].unwrap());",
      "                a = self.parent[k][a].unwrap();",
      "                b = self.parent[k][b].unwrap();",
      "            }",
      "        }",
      "        if self.parent[0][a] == None && self.parent[0][b] == None {",
      "            None",
      "        } else {",
      "            ret = f(ret, self.weight[0][a].unwrap());",
      "            ret = f(ret, self.weight[0][b].unwrap());",
      "            Some(ret)",
      "        }",
      "    }",
      "}"
    ]
  },

  "programmingContenst": {
    "prefix": "pro",
    "body": [
      "#![allow(non_snake_case)]",
      "#[allow(unused_imports)]",
      "use std::io::{self, Write};",
      "#[allow(unused_imports)]",
      "use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};",
      "#[allow(unused_imports)]",
      "use std::cmp::{max, min, Ordering};",
      "macro_rules! input {",
      "    (source = \\$s:expr, \\$(\\$r:tt)*) => {",
      "        let mut iter = \\$s.split_whitespace();",
      "        let mut next = || { iter.next().unwrap() };",
      "        input_inner!{next, \\$(\\$r)*}",
      "    };",
      "    (\\$(\\$r:tt)*) => {",
      "        let stdin = std::io::stdin();",
      "        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));",
      "        let mut next = move || -> String{",
      "            bytes",
      "                .by_ref()",
      "                .map(|r|r.unwrap() as char)",
      "                .skip_while(|c|c.is_whitespace())",
      "                .take_while(|c|!c.is_whitespace())",
      "                .collect()",
      "        };",
      "        input_inner!{next, \\$(\\$r)*}",
      "    };",
      "}",
      "macro_rules! input_inner {",
      "    (\\$next:expr) => {};",
      "    (\\$next:expr, ) => {};",
      "    (\\$next:expr, \\$var:ident : \\$t:tt \\$(\\$r:tt)*) => {",
      "        let \\$var = read_value!(\\$next, \\$t);",
      "        input_inner!{\\$next \\$(\\$r)*}",
      "    };",
      "}",
      "macro_rules! read_value {",
      "    (\\$next:expr, ( \\$(\\$t:tt),* )) => {",
      "        ( \\$(read_value!(\\$next, \\$t)),* )",
      "    };",
      "    (\\$next:expr, [ \\$t:tt ; \\$len:expr ]) => {",
      "        (0..\\$len).map(|_| read_value!(\\$next, \\$t)).collect::<Vec<_>>()",
      "    };",
      "    (\\$next:expr, chars) => {",
      "        read_value!(\\$next, String).chars().collect::<Vec<char>>()",
      "    };",
      "    (\\$next:expr, char) => {",
      "        read_value!(\\$next, String).chars().collect::<Vec<char>>()[0]",
      "     };",
      "    (\\$next:expr, usize1) => {",
      "        read_value!(\\$next, usize) - 1",
      "     };",
      "    (\\$next:expr, isize1) => {",
      "        read_value!(\\$next, isize) - 1",
      "    };",
      "     (\\$next:expr, \\$t:ty) => {",
      "         \\$next().parse::<\\$t>().expect(\"Parse error\")",
      "    };",
      "}",
      "macro_rules! printvec {",
      "    ( \\$item:expr ) => {",
      "        for &i in &\\$item {",
      "            print!(\"{} \", i);",
      "        }",
      "        println!(\"\");",
      "    }",
      "}",
      "macro_rules! debug {",
      "    (\\$(\\$a:expr),*) => {",
      "        println!(concat!(\\$(stringify!(\\$a), \" = {:?}, \"),*), \\$(\\$a),*);",
      "    }",
      "}",
      "#[derive(Eq, PartialEq, Clone, Debug)]",
      "pub struct Rev<T>(pub T);",
      "impl<T: PartialOrd> PartialOrd for Rev<T> {",
      "    fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {",
      "        other.0.partial_cmp(&self.0)",
      "    }",
      "}",
      "impl<T: Ord> Ord for Rev<T> {",
      "    fn cmp(&self, other: &Rev<T>) -> Ordering {",
      "        other.0.cmp(&self.0)",
      "    }",
      "}",
      "#[derive(PartialEq, PartialOrd, Clone, Debug)]",
      "pub struct Total<T>(pub T);",

      "impl<T: PartialEq> Eq for Total<T> {}",

      "impl<T: PartialOrd> Ord for Total<T> {",
      "    fn cmp(&self, other: &Total<T>) -> Ordering {",
      "        self.0.partial_cmp(&other.0).unwrap()",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "const MOD: usize = 1000000007;",
      "\n",
      "fn main() {",
      "    input!{",
      "        N: usize,",
      "    }",
      "}"
    ]
  },
  "utils": {
    "prefix": "utils",
    "body": [
      "trait CharUtils {",
      "    fn to_num(self) -> usize;",
      "}",
      "impl CharUtils for char {",
      "    fn to_num(self) -> usize {",
      "        self as usize",
      "    }",
      "}",
      "trait UsizeUtils {",
      "    fn sqrt_floor(self) -> usize;",
      "    fn sqrt_ceil(self) -> usize;",
      "    fn factors(self) -> HashMap<usize, usize>;",
      "    fn digits(self) -> usize;",
      "    fn bit_length(self) -> usize;",
      "}",
      "impl UsizeUtils for usize {",
      "    fn sqrt_floor(self) -> usize {",
      "        (self as f64).sqrt() as usize",
      "    }",
      "    fn sqrt_ceil(self) -> usize {",
      "        let tmp = (self as f64).sqrt() as usize;",
      "        if tmp * tmp == self {",
      "            tmp",
      "        } else {",
      "            tmp + 1",
      "        }",
      "    }",
      "    fn factors(self) -> HashMap<usize, usize> {",
      "        let mut facs: HashMap<usize, usize> = HashMap::new();",
      "        let mut n = self;",
      "        let mut a = 2;",
      "        while n >= a*a {",
      "            if n % a == 0{",
      "                n /= a;",
      "                *facs.entry(a).or_insert(0) += 1;",
      "            } else {",
      "                a += 1;",
      "            }",
      "        }",
      "        *facs.entry(n).or_insert(0) += 1;",
      "        facs",
      "    }",
      "    fn digits(self) -> usize {",
      "        (self as f64).log10() as usize + 1",
      "    }",
      "fn bit_length(self) -> usize {",
      "    let mut ret = 0;",
      "    let mut n = self;",
      "    while n > 0 {",
      "        ret += 1;",
      "        n >>= 1;",
      "    }",
      "    ret",
      "}",
      "}",
      "trait VecUtils<T> {",
      "    fn transpose(&self) -> Vec<Vec<&T>>;",
      "}",
      "impl<T> VecUtils<T> for Vec<Vec<T>> {",
      "    fn transpose(&self) -> Vec<Vec<&T>> {",
      "        (0..self[0].len()).map(|j|  (0..self.len()).map(|i| &self[i][j]).collect::<Vec<&T>>()).collect::<Vec<Vec<&T>>>()",
      "    }",
      "}"
    ]
  }
}
